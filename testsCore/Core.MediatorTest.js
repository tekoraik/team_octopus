/**
 * @author Rafael Yepes
 */
;(function(win, doc, mediator) {
    TestCase("mediatorTest", {
        setUp: function () {},
        tearDown: function () {},
        "test that mediator exists" : function () {
            assertNotUndefined(mediator);
        },
        "test that mediator is an object" : function () {
            var sObjectType = mediator.toString();
            assertEquals("[object Object]", sObjectType);
        }
    });
    TestCase("mediatorSubscribeTest", {
        setUp: function () {},
        tearDown: function () {
            mediator.subscriptions = {};
        },
        "test that the method mediator.subscribe exists" : function () {
            assertNotUndefined(mediator.subscribe);
            assertFunction(mediator.subscribe);
        },
        "test that calling mediator.subscribe returns the mediator": function () {
            assertEquals(mediator, mediator.subscribe());
        },
        "test that the first parameter of subscribe generates a new object as property of mediator.\
        subscriptions": function() {
            var sChannel = "Example",
                sObjectType;
            assertUndefined(mediator.subscriptions[sChannel]);
            mediator.subscribe(sChannel);
            assertNotUndefined(mediator.subscriptions[sChannel]);
            sObjectType = mediator.subscriptions[sChannel].toString();
            assertEquals("[object Object]", sObjectType);
        },
        "test that the second parameter of subscribe generates a new array as property of the\
        object generated by the first argument": function () {
            var sChannel = "Example Channel",
                sEvent = "Example Event";
            assertUndefined(mediator.subscriptions[sChannel]);
            mediator.subscribe(sChannel, sEvent);
            assertNotUndefined(mediator.subscriptions[sChannel]);
            assertNotUndefined(mediator.subscriptions[sChannel][sEvent]);
            assertArray(mediator.subscriptions[sChannel][sEvent]);
        },
        "test that the third argument of subscribe is a function added as method 'callback' of a\
        new object added to the array generated by the second argument": function () {
            var sChannel = "Example Channel",
                sEvent = "Example Event",
                fpCallback = function () {};
            assertUndefined(mediator.subscriptions[sChannel]);
            mediator.subscribe(sChannel, sEvent, fpCallback);
            assertNotUndefined(mediator.subscriptions[sChannel]);
            assertNotUndefined(mediator.subscriptions[sChannel][sEvent]);
            assertNotUndefined(mediator.subscriptions[sChannel][sEvent][0]);
            assertObject(mediator.subscriptions[sChannel][sEvent][0]);
            assertNotUndefined(mediator.subscriptions[sChannel][sEvent][0].callback);
            assertEquals(fpCallback, mediator.subscriptions[sChannel][sEvent][0].callback);
        },
        "test that the fourth argument of subscribe is added as the property 'context' of the new\
        object added to the array generated by the third argument": function () {
            var sChannel = "Example Channel",
                sEvent = "Example Event",
                fpCallback = function () {},
                oContext = {};
            assertUndefined(mediator.subscriptions[sChannel]);
            mediator.subscribe(sChannel, sEvent, fpCallback, oContext);
            assertNotUndefined(mediator.subscriptions[sChannel]);
            assertNotUndefined(mediator.subscriptions[sChannel][sEvent]);
            assertNotUndefined(mediator.subscriptions[sChannel][sEvent][0]);
            assertObject(mediator.subscriptions[sChannel][sEvent][0]);
            assertNotUndefined(mediator.subscriptions[sChannel][sEvent][0].context);
            assertEquals(oContext, mediator.subscriptions[sChannel][sEvent][0].context);
        }
    });
    TestCase("mediatorUnsubscribeTest", {
        setUp: function () {},
        tearDown: function () {
            mediator.subscriptions = {};
        },
        "test that the method mediator.unsubscribe exists" : function () {
            assertNotUndefined(mediator.unsubscribe);
            assertFunction(mediator.unsubscribe);
        },
        "test that calling mediator.unsubscribe returns the mediator": function () {
            assertEquals(mediator, mediator.unsubscribe());
        },
        //TODO more tests
        "test that calling mediator.unsubscribe, with all 3 parameters and all them are right\
        (the meant object exist in the subscription list), then the subscripted element is removed\
        from the subscription list": function () {
            var sChannel1 = "Channel1",
                sChannel2 = "Channel2",
                sEvent1 = "Event1",
                sEvent2 = "Event2",
                fpCallback1 = function () {},
                fpCallback2 = function () {};
            mediator.subscriptions[sChannel1] = {};
            mediator.subscriptions[sChannel1][sEvent1] = [];
            mediator.subscriptions[sChannel1][sEvent1].push(
                {context: undefined, callback: fpCallback1});
            mediator.subscriptions[sChannel2] = {};
            mediator.subscriptions[sChannel2][sEvent2] = [];
            mediator.subscriptions[sChannel2][sEvent2].push(
                {context: undefined, callback: fpCallback2});
            assertNotUndefined(mediator.subscriptions[sChannel1][sEvent1]);
            assertNotUndefined(mediator.subscriptions[sChannel2][sEvent2]);
            mediator.unsubscribe(sChannel1, sEvent1, fpCallback1);
            assertUndefined(mediator.subscriptions[sChannel1][sEvent1]);
            mediator.unsubscribe(sChannel2, sEvent2, fpCallback1);
            assertNotUndefined(mediator.subscriptions[sChannel2][sEvent2]);
        }
    });
    TestCase("mediatorPublishTest", {
        setUp: function () {
            this.sChannel1 = "Channel1";
            this.sChannel2 = "Channel2";
            this.sEvent1 = "Event1";
            this.sEvent2 = "Event2";
            this.fpCallback1 = function () {};
            this.fpCallback2 = function () {};
            this.oContext1 = {name: "context 1"};
            this.oContext2 = {name: "context 2"};
            this.oCallbackObject1 = {context: this.oContext1, callback: this.fpCallback1};
            this.oCallbackObject2 = {context: this.oContext2, callback: this.fpCallback2};
            mediator.subscriptions[this.sChannel1] = {};
            mediator.subscriptions[this.sChannel1][this.sEvent1] = [];
            mediator.subscriptions[this.sChannel1][this.sEvent1].push(this.oCallbackObject1);
            mediator.subscriptions[this.sChannel2] = {};
            mediator.subscriptions[this.sChannel2][this.sEvent2] = [];
            mediator.subscriptions[this.sChannel2][this.sEvent2].push(this.oCallbackObject2);
        },
        tearDown: function () {
            mediator.subscriptions = {};
        },
        "test that the method mediator.publish exists" : function () {
            assertNotUndefined(mediator.publish);
            assertFunction(mediator.publish);
        },
        "test that calling mediator.publish returns the mediator": function () {
            assertEquals(mediator, mediator.publish());
        },
        "test that publishing and event in a channel make all the callback function subscribed to\
        that event and channel to get invoked" : function () {
            var spy1 = sinon.spy(this.oCallbackObject1, "callback"),
                spy2 = sinon.spy(this.oCallbackObject2, "callback"),
                spy3,
                oCallbackObject3;
            assertFalse(spy1.called);
            assertFalse(spy2.called);
            mediator.publish(this.sChannel1, this.sEvent1);
            assert(spy1.calledOnce);
            assertFalse(spy2.called);
            oCallbackObject3 = {context: this.oContext1, callback: this.fpCallback2};
            spy3 = sinon.spy(oCallbackObject3, "callback");
            mediator.subscriptions[this.sChannel1][this.sEvent1].push(oCallbackObject3);
            mediator.publish(this.sChannel1, this.sEvent1);
            assert(spy1.calledTwice);
            assertFalse(spy2.called);
            assert(spy3.calledOnce);
        },
        /* I don't know how to test that. I don't even know if it's possible.
        "test that when a callback function is invoked when publishing, it is called with is\
        concrete that was stored in the property 'context' of the object previously added to the\
        subscription list": function () {

        },
        */
        "test that when publishing with more than 2 arguments, those extra arguments are passed\
        to the callback function that is going to be called as arguments": function () {
            var spy = sinon.spy(this.oCallbackObject1, "callback"),
                sFirstArgument = "I'm the first",
                oSecondArgument = {name: "I'm the second"},
                fpThirdArgument = function () {return "I'm the third";};
            assertFalse(spy.called);
            mediator.publish(this.sChannel1, this.sEvent1, sFirstArgument, oSecondArgument,
                fpThirdArgument);
            assert(spy.withArgs(sFirstArgument, oSecondArgument, fpThirdArgument).calledOnce);
        }
    });
    TestCase("mediatorUnsubscribeAllTest", {
        setUp: function () {
            this.sChannel1 = "Channel1";
            this.sChannel2 = "Channel2";
            this.sEvent1 = "Event1";
            this.sEvent2 = "Event2";
            this.fpCallback1 = function () {};
            this.fpCallback2 = function () {};
            this.oContext1 = {name: "context 1"};
            this.oContext2 = {name: "context 2"};
            this.oCallbackObject1 = {context: this.oContext1, callback: this.fpCallback1};
            this.oCallbackObject2 = {context: this.oContext2, callback: this.fpCallback2};
            mediator.subscriptions[this.sChannel1] = {};
            mediator.subscriptions[this.sChannel1][this.sEvent1] = [];
            mediator.subscriptions[this.sChannel1][this.sEvent1].push(this.oCallbackObject1);
            mediator.subscriptions[this.sChannel2] = {};
            mediator.subscriptions[this.sChannel2][this.sEvent2] = [];
            mediator.subscriptions[this.sChannel2][this.sEvent2].push(this.oCallbackObject2);
        },
        tearDown: function () {
            mediator.subscriptions = {};
        },
        "test that the method mediator.unsubscribeAll exists" : function () {
            assertNotUndefined(mediator.unsubscribeAll);
            assertFunction(mediator.unsubscribeAll);
        },
        "test that calling mediator.unsubscribeAll returns the mediator": function () {
            assertEquals(mediator, mediator.unsubscribeAll());
        },
        "test that calling mediator.unsubscribeAll sets the object mediator.subscriptions to {}":
        function () {
            assertNotEquals({}, mediator.subscriptions);
            mediator.unsubscribeAll();
            assertEquals({}, mediator.subscriptions);
        }
    });
})(window, document, Core.Mediator);